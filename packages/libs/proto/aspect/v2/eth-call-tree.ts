// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v1.3.0
//   protoc        v4.25.1

import { Protobuf, Reader, Writer } from 'as-proto/assembly';
import { EthCallMessage } from './eth-call-message';

export class EthCallTree {
  static encode(message: EthCallTree, writer: Writer): void {
    const calls = message.calls;
    if (calls !== null) {
      const callsKeys = calls.keys();
      for (let i: i32 = 0; i < callsKeys.length; ++i) {
        const callsKey = callsKeys[i];
        writer.uint32(10);
        writer.fork();
        writer.uint32(8);
        writer.uint64(callsKey);
        writer.uint32(18);
        writer.fork();
        EthCallMessage.encode(calls.get(callsKey), writer);
        writer.ldelim();
        writer.ldelim();
      }
    }
  }

  static decode(reader: Reader, length: i32): EthCallTree {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new EthCallTree();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          let callsKey: u64 = 0;
          let callsValue: EthCallMessage | null = null;
          let callsHasKey: bool = false;
          let callsHasValue: bool = false;
          for (const end: usize = reader.ptr + reader.uint32(); reader.ptr < end; ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                callsKey = reader.uint64();
                callsHasKey = true;
                break;

              case 2:
                callsValue = EthCallMessage.decode(reader, reader.uint32());
                callsHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.calls === null) {
              message.calls = new Map<u64, EthCallMessage>();
            }
            const calls = message.calls;
            if (calls !== null && callsHasKey && callsHasValue && callsValue !== null) {
              calls.set(callsKey, callsValue);
            }
          }
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  calls: Map<u64, EthCallMessage>;

  constructor(calls: Map<u64, EthCallMessage> = new Map()) {
    this.calls = calls;
  }
}

export function encodeEthCallTree(message: EthCallTree): Uint8Array {
  return Protobuf.encode(message, EthCallTree.encode);
}

export function decodeEthCallTree(buffer: Uint8Array): EthCallTree {
  return Protobuf.decode<EthCallTree>(buffer, EthCallTree.decode);
}
